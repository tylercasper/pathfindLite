-- MmapLuaLoader.lua
-- Loads CMaNGOS navmesh and terrain data from Lua “blob” addons (QuestHelper-style),
-- instead of reading .mmap/.mmtile/.map files from disk.
--
-- Drop-in replacement for MmapFileLoader.lua:
--   loadNavMeshParams(dataDir, mapId)       -> bytes (28) or nil, path
--   loadNavTile(dataDir, mapId, tx, ty)     -> bytes or nil, path
--   loadTerrainTile(dataDir, mapId, tx, ty) -> bytes or nil, path
--
-- Data is generated by tools/convert_mmaps_to_lua.py and stored in:
--   Core addon:  <addon_prefix>/MmapLuaDB_Core.lua
--   Shard addons: <addon_prefix>_%03d_%02d_%02d/data.lua  (LoadOnDemand)
--
-- WoW runtime:
--   Uses LoadAddOn()/IsAddOnLoaded() to load shard addons on demand.
-- External runtime:
--   Uses dofile() to execute the same Lua files from a directory that contains
--   the generated addon folders (dataDir points to the AddOns directory).

local M = {}

local strbyte = string.byte
local strsub  = string.sub

local DEFAULT_ADDON_PREFIX = "qhstub_mmapdata"
local DEFAULT_SHARD_DIM = 8
local SHARD_LUA_FILENAME = "data.lua"
local CORE_LUA_FILENAME = "MmapLuaDB_Core.lua"
local CORE_LIBDEFLATE_FILENAME = "LibDeflate.lua"

local loaded_addons = {}
local missing_addons = {}

local function dbg(msg)
  if not rawget(_G, "MmapLuaLoaderDebug") then return end
  local qhs = rawget(_G, "QHS")
  if type(qhs) == "table" and type(qhs.chat) == "function" then
    qhs.chat(msg)
  elseif type(DEFAULT_CHAT_FRAME) == "table" and type(DEFAULT_CHAT_FRAME.AddMessage) == "function" then
    DEFAULT_CHAT_FRAME:AddMessage(tostring(msg))
  elseif type(print) == "function" then
    print(tostring(msg))
  end
end

local function dbgf(fmt, ...)
  if not rawget(_G, "MmapLuaLoaderDebug") then return end
  local ok, s = pcall(string.format, tostring(fmt), ...)
  dbg(ok and s or fmt)
end

-- ---------------------------------------------------------------------------
-- QuestHelper-style adaptint + BST index lookup (ported from qhstub_db.lua)
-- ---------------------------------------------------------------------------

local function read_adaptint(data, offset)
  local stx = 0
  local acu = 1
  while true do
    local v = strbyte(data, offset)
    if not v then return nil, offset end
    stx = stx + acu * math.floor(v / 2)
    offset = offset + 1
    acu = acu * 128
    if (v % 2) == 0 then break end
  end
  return stx, offset
end

local function search_index(index, data, item)
  if type(index) ~= "string" or type(data) ~= "string" or type(item) ~= "number" then
    return nil
  end

  local cofs = 1
  while true do
    local idx
    idx, cofs = read_adaptint(index, cofs)
    if not idx or idx == 0 then return nil end

    local ofs, lenm1, rlink
    ofs, cofs = read_adaptint(index, cofs)
    lenm1, cofs = read_adaptint(index, cofs)
    rlink, cofs = read_adaptint(index, cofs)
    if not ofs or not lenm1 or not rlink then return nil end

    if idx == item then
      return strsub(data, ofs, ofs + lenm1)
    end
    if idx < item then
      cofs = cofs + rlink
    end
  end
end

-- ---------------------------------------------------------------------------
-- Environment helpers
-- ---------------------------------------------------------------------------

local function is_wow_runtime()
  -- Prefer positive detection of external Lua (dofile available).
  -- In WoW, dofile is not available but LoadAddOn is.
  if type(dofile) == "function" then return false end
  local LoadAddOn = rawget(_G, "LoadAddOn")
  if type(LoadAddOn) == "function" then return true end
  local C_AddOns = rawget(_G, "C_AddOns")
  if type(C_AddOns) == "table" and type(C_AddOns.LoadAddOn) == "function" then return true end
  return false
end

local function wow_addon_api()
  local _LoadAddOn = rawget(_G, "LoadAddOn")
  local _IsAddOnLoaded = rawget(_G, "IsAddOnLoaded")
  local _GetAddOnEnableState = rawget(_G, "GetAddOnEnableState")

  local C_AddOns = rawget(_G, "C_AddOns")
  if type(C_AddOns) == "table" then
    if type(_LoadAddOn) ~= "function" then _LoadAddOn = C_AddOns.LoadAddOn end
    if type(_IsAddOnLoaded) ~= "function" then _IsAddOnLoaded = C_AddOns.IsAddOnLoaded end
    if type(_GetAddOnEnableState) ~= "function" then _GetAddOnEnableState = C_AddOns.GetAddOnEnableState end
  end

  return _LoadAddOn, _IsAddOnLoaded, _GetAddOnEnableState
end

local function join_path(a, b)
  if not a or a == "" then return b end
  if not b or b == "" then return a end
  -- Accept either / or \\; produce / for consistency.
  a = tostring(a):gsub("\\", "/")
  b = tostring(b):gsub("\\", "/")
  if a:sub(-1) == "/" then return a .. b end
  return a .. "/" .. b
end

local function resolve_addon_prefix()
  local db = rawget(_G, "MmapLuaDB")
  local cfg = (type(db) == "table") and rawget(db, "config") or nil
  if type(cfg) == "table" and type(cfg.addon_prefix) == "string" and cfg.addon_prefix ~= "" then
    return cfg.addon_prefix
  end

  local gp = rawget(_G, "MmapLuaAddonPrefix")
  if type(gp) == "string" and gp ~= "" then return gp end

  return DEFAULT_ADDON_PREFIX
end

local function resolve_shard_dim()
  local db = rawget(_G, "MmapLuaDB")
  local cfg = (type(db) == "table") and rawget(db, "config") or nil
  local d = (type(cfg) == "table") and tonumber(cfg.shard_dim) or nil
  if type(d) == "number" and d > 0 then return math.floor(d) end
  return DEFAULT_SHARD_DIM
end

local function get_libdeflate()
  -- WoW: prefer LibStub registration if present.
  if type(LibStub) == "table" and type(LibStub.GetLibrary) == "function" then
    local lib = LibStub:GetLibrary("LibDeflate", true)
    if type(lib) == "table" and type(lib.DecompressDeflate) == "function" then
      return lib
    end
  end
  -- Fallback: global
  local g = rawget(_G, "LibDeflate")
  if type(g) == "table" and type(g.DecompressDeflate) == "function" then
    return g
  end
  -- External: try require if available.
  if type(require) == "function" then
    local ok, lib = pcall(require, "LibDeflate")
    if ok and type(lib) == "table" and type(lib.DecompressDeflate) == "function" then
      return lib
    end
  end
  return nil
end

local function ensure_addon_loaded(dataDir, addonName, addonFolderHint, luaFileNameHint)
  if missing_addons[addonName] then
    dbgf("mmaplua: skip LoadAddOn(%s); previously failed reason=%s", tostring(addonName), tostring(missing_addons[addonName]))
    return false
  end
  if loaded_addons[addonName] then return true end

  if is_wow_runtime() then
    local _LoadAddOn, _IsAddOnLoaded, _GetAddOnEnableState = wow_addon_api()
    if type(_IsAddOnLoaded) == "function" and _IsAddOnLoaded(addonName) then
      loaded_addons[addonName] = true
      return true
    end
    local debug = rawget(_G, "MmapLuaLoaderDebug")
    local t0 = (debug and type(debugprofilestop) == "function") and debugprofilestop() or nil
    if debug then
      dbgf("mmaplua: runtime=WoW LoadAddOn=%s IsAddOnLoaded=%s dofile=%s",
        tostring(type(_LoadAddOn)), tostring(type(_IsAddOnLoaded)), tostring(type(dofile)))
      local en = (type(_GetAddOnEnableState) == "function" and type(UnitName) == "function")
        and _GetAddOnEnableState(UnitName("player"), addonName)
        or nil
      dbgf("mmaplua: LoadAddOn(%s) ... (enableState=%s)", tostring(addonName), tostring(en))
    end
    local ok, reason
    if type(_LoadAddOn) == "function" then
      ok, reason = _LoadAddOn(addonName)
    end
    if debug then
      local dt = (t0 and type(debugprofilestop) == "function") and (debugprofilestop() - t0) or nil
      dbgf("mmaplua: LoadAddOn(%s) -> ok=%s reason=%s (%s ms)",
        tostring(addonName), tostring(ok), tostring(reason), dt and string.format("%.0f", dt) or "?")
    end
    if ok then
      loaded_addons[addonName] = true
      return true
    end
    if debug then
      local loaded = (type(_IsAddOnLoaded) == "function") and _IsAddOnLoaded(addonName) or nil
      dbgf("mmaplua: load FAILED for %s (IsAddOnLoaded=%s)", tostring(addonName), tostring(loaded))
    end
    missing_addons[addonName] = reason or true
    return false
  end

  -- External environment: dofile the shard Lua file directly.
  if type(dofile) ~= "function" then
    dbgf("mmaplua: runtime=UNKNOWN (no LoadAddOn, no dofile) addon=%s", tostring(addonName))
    -- Don't cache this as "missing": we might be in WoW but can't see LoadAddOn here.
    return false
  end

  local folder = addonFolderHint or addonName
  local luaFile = luaFileNameHint or SHARD_LUA_FILENAME
  local path = join_path(join_path(dataDir, folder), luaFile)
  local ok = pcall(dofile, path)
  if ok then
    loaded_addons[addonName] = true
    return true
  end
  missing_addons[addonName] = true
  return false
end

local function ensure_core_loaded(dataDir)
  local db = rawget(_G, "MmapLuaDB")
  if type(db) == "table" and type(db.params) == "table" then
    return true
  end

  local prefix = resolve_addon_prefix()

  -- WoW: attempt LoadAddOn(core) if possible (core should normally be enabled/loaded).
  if is_wow_runtime() then
    dbgf("mmaplua: ensure_core_loaded prefix=%s", tostring(prefix))
    ensure_addon_loaded(dataDir, prefix, prefix, CORE_LUA_FILENAME)
    db = rawget(_G, "MmapLuaDB")
    dbgf("mmaplua: core loaded? db=%s params=%s",
      tostring(type(db)),
      tostring(type(db) == "table" and type(rawget(db, "params")) or nil))
    return type(db) == "table" and type(db.params) == "table"
  end

  -- External: dofile LibDeflate.lua then core DB.
  if type(dofile) == "function" and type(dataDir) == "string" and dataDir ~= "" then
    do
      local ok, lib = pcall(dofile, join_path(join_path(dataDir, prefix), CORE_LIBDEFLATE_FILENAME))
      -- Some Lua builds return the module table but do not reliably populate a global.
      if ok and type(lib) == "table" and type(lib.DecompressDeflate) == "function" and rawget(_G, "LibDeflate") == nil then
        _G.LibDeflate = lib
      end
    end
    pcall(dofile, join_path(join_path(dataDir, prefix), CORE_LUA_FILENAME))
  end
  db = rawget(_G, "MmapLuaDB")
  return type(db) == "table" and type(db.params) == "table"
end

local function get_shard_table(mapId, sx, sy)
  local db = rawget(_G, "MmapLuaDB")
  local shards = (type(db) == "table") and rawget(db, "shards") or nil
  local mtab = (type(shards) == "table") and shards[mapId] or nil
  local stab = (type(mtab) == "table") and mtab[sx] or nil
  local shard = (type(stab) == "table") and stab[sy] or nil
  return shard
end

local function ensure_shard_loaded(dataDir, mapId, sx, sy)
  if get_shard_table(mapId, sx, sy) then return true end

  local prefix = resolve_addon_prefix()
  local addonName = string.format("%s_%03d_%02d_%02d", prefix, mapId, sx, sy)
  dbgf("mmaplua: ensure_shard_loaded %s (map=%d sx=%d sy=%d)", tostring(addonName), mapId, sx, sy)
  ensure_addon_loaded(dataDir, addonName, addonName, SHARD_LUA_FILENAME)
  if not get_shard_table(mapId, sx, sy) then
    dbgf("mmaplua: shard table missing after load (map=%d sx=%d sy=%d)", mapId, sx, sy)
  end
  return not not get_shard_table(mapId, sx, sy)
end

local function decompress_deflate(comp)
  local lib = get_libdeflate()
  if not lib then return nil, "LibDeflate missing" end
  local ok, out = pcall(function()
    return lib:DecompressDeflate(comp)
  end)
  if not ok then return nil, "decompress error" end
  if type(out) ~= "string" then return nil, "decompress failed" end
  return out
end

local function tile_key(tx, ty)
  return tx * 64 + ty + 1
end

local function mmap_params_path(dataDir, mapId)
  return string.format("%s/mmaps/%03d.mmap", tostring(dataDir or "lua"), mapId)
end
local function nav_tile_path(dataDir, mapId, tx, ty)
  return string.format("%s/mmaps/%03d%02d%02d.mmtile", tostring(dataDir or "lua"), mapId, tx, ty)
end
local function terrain_tile_path(dataDir, mapId, tx, ty)
  return string.format("%s/maps/%03d%02d%02d.map", tostring(dataDir or "lua"), mapId, tx, ty)
end

-- ---------------------------------------------------------------------------
-- Public API (matches MmapFileLoader.lua)
-- ---------------------------------------------------------------------------

function M.loadNavMeshParams(dataDir, mapId)
  local path = mmap_params_path(dataDir, mapId)
  if not ensure_core_loaded(dataDir) then return nil, path end

  local db = rawget(_G, "MmapLuaDB")
  local params = db and db.params and db.params[mapId]
  if type(params) ~= "string" or #params < 28 then
    return nil, path
  end
  if #params ~= 28 then
    -- Be strict: return the first 28 bytes only.
    params = params:sub(1, 28)
  end
  return params, path
end

function M.loadNavTile(dataDir, mapId, tx, ty)
  local path = nav_tile_path(dataDir, mapId, tx, ty)
  if not ensure_core_loaded(dataDir) then return nil, path end

  local shardDim = resolve_shard_dim()
  local sx = math.floor(tx / shardDim)
  local sy = math.floor(ty / shardDim)
  if not ensure_shard_loaded(dataDir, mapId, sx, sy) then return nil, path end

  local shard = get_shard_table(mapId, sx, sy)
  local nav = shard and shard.nav
  if type(nav) ~= "table" then return nil, path end

  local comp = search_index(nav.serialize_index, nav.serialize_data, tile_key(tx, ty))
  if type(comp) ~= "string" or comp == "" then return nil, path end

  local bytes = decompress_deflate(comp)
  if type(bytes) ~= "string" or #bytes < 20 then
    return nil, path
  end
  return bytes, path
end

function M.loadTerrainTile(dataDir, mapId, tx, ty)
  local path = terrain_tile_path(dataDir, mapId, tx, ty)
  if not ensure_core_loaded(dataDir) then return nil, path end

  local shardDim = resolve_shard_dim()
  local sx = math.floor(tx / shardDim)
  local sy = math.floor(ty / shardDim)
  if not ensure_shard_loaded(dataDir, mapId, sx, sy) then return nil, path end

  local shard = get_shard_table(mapId, sx, sy)
  local terr = shard and shard.terrain
  if type(terr) ~= "table" then return nil, path end

  local comp = search_index(terr.serialize_index, terr.serialize_data, tile_key(tx, ty))
  if type(comp) ~= "string" or comp == "" then
    return nil, path -- missing terrain tile is OK
  end

  local bytes = decompress_deflate(comp)
  if type(bytes) ~= "string" then return nil, path end
  return bytes, path
end

if package and package.loaded then
  package.loaded["MmapLuaLoader"] = M
end
return M

